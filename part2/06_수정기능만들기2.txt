수정기능 만들기 2 (저번시간 숙제)

 

0:00 일단 수정페이지 이동 링크 만들기

1:55 3. 전송누르면 DB 글 수정

6:33 서버는 어떤 _id의 글을 수정할지 모르는데요

10:36 예외처리, 수정결과 확인법, input 숨기기

 

 

오늘은 딱히 새로배우는 내용이 없어서

수정기능이 잘 동작하면 다음 강의나 들어보도록 합시다. 

 

 

 

 

일단 수정페이지 이동 링크부터

 

저는 수정페이지로 쉽게 이동하고 싶으니까 링크부터 만들어볼 것입니다. 

/list 페이지로 가봅시다. 

 

(list.ejs)

<div class="white-bg">
  <% for (let i = 0; i < 글목록.length; i++){ %>
    <div class="list-box">
      <h4>
        <a href="/detail/<%= 글목록[i]._id %>">
          <%= 글목록[i].title %>
        </a>
        <a href="/edit/글의_id">✏️</a>
      </h4>
      <p>글내용임</p>
    </div>
  <% } %>
</div>

연필 누르면 /edit/글의_id 로 이동하게 코드짜봅시다. 

글의_id 는 코드로 뭐냐고요? 

위에 <%= 글목록 %> 변수를 쓰면 모든 글이 담겨있는데 거기에 _id도 있을 것 같군요.

그래서 글의_id 자리엔 <%= 글목록[i]._id %> 집어넣으면 될듯요 

 

하지만 언제나 지레짐작하면서 코딩하면 안되고 어떤 값이 들어있는지 출력해보는게 좋은 습관입니다. 

코딩을 책이나 글로 따라치기만 했던 분들이 보통 지레짐작코딩하는 경우가 많던 것 같습니다. 

 

 

 

 

 

 

3. 전송버튼 누르면 그걸로 기존에 있던 document를 수정

 

이거 구현하면 끝인데 

유저가 직접 DB에 있는걸 수정하게 냅둘 순 없기에 

서버로 글을 우선 전달부터하고 서버는 그걸 확인한 다음에 DB수정을 해줍시다.

서버로 전달하는건 

 

 

(edit.ejs)

<form class="form-box" action="/edit" method="POST">
  (생략)
</form>

edit.ejs 파일 가보시면 <form>이 있는데

여기다가 method, url 잘 기입하면 서버로 글을 전송할 수 있습니다. 

저는 /edit, POST를 선택해봤습니다. 

 

(참고) <form> 에선 GET, POST만 가능하고 PUT, DELETE 요청은 보낼 수 없습니다. 

PUT 같은거 쓰면 좀 더 이쁜 API를 만들 수 있다고 했는데 맘대로 쓸 수 없는 냉혹한 세상임 

다음 강의에 나올 method-override 쓰면 될 수도 있습니다. 

 

 

 

 

 

app.post('/edit', async (요청, 응답)=>{
  await db.collection('post').updateOne({ ??? },
    {$set : { ??? }
  })
  응답.redirect('/list')
}) 

그럼 서버에서도 /edit으로 POST요청받는 API 하나 만들어봅시다. 

누가 /edit으로 post요청하면 db게시물 수정해주세요 라고 코드짜버렸음 

이제 저거 물음표자리에 뭐 채워넣을지 고민하면 됩니다. 

 

둘 째 물음표는 어떤 내용으로 기존 document를 수정할지를 집어넣으면 되는데 

어떤 내용 ← 이건 요청.body 안에 담겨있지 않을까요 

그래서 요청.body 안에서 주섬주섬 꺼내서 채우면 될 것 같습니다. 

 

그럼 첫 물음표자리엔 어떤 document를 찾아서 수정할지 적으면 되는데

보통 _id로 찾는게 정확하기 때문에 

{_id : 어쩌구} 이런거 적으면 좋겠군요. 

어쩌구 자리에는 뭘 집어넣어요? 

아마 서버는 모르죠 그럼 어떻게해요?

손가락 빨면서 선생님의 코드를 기다립니다. 

 

 

 

 

그러면 안되고 서버에 없는 정보는 유저에게 보내라고 하거나

DB에서 뽑아보거나 둘 중 하나 하면 보통 해결됩니다.

"어떤 document를 수정하고 싶은지"는 서버는 모르고 유저만 알고있기 때문에 유저에게 보내라고 하면 됩니다. 

유저에게 수정할 글의 _id를 보내라고 합시다.

 

 

 

 

 

 

유저야 수정할 글의 _id도 보내라

 

(edit.ejs)

<form class="form-box" action="/edit" method="POST">
  (생략)
</form>

edit.ejs 파일 가보시면 <form>이 있는데

여기다가 <input>하나 만들어서 수정하고싶은 글 id도 보내라고 하면 되는거아닙니까

그러면 될거같습니다.

근데 유저가 천재도 아니고 id를 어떻게 기입하냐구요?

그럼 여러분들이 대신 써주면 되는거 아닙니까 

 

 

 

 

(edit.ejs)

<form class="form-box" action="/edit" method="POST">
  <h4>수정하기</h4>
  <input name="id" value="<%= result._id %>">
  <input name="title" value="<%= result.title %>">
  <input name="content" value="<%= result.content %>">
</form>

수정하고 싶은 글의 _id를 <input>에 집어넣으면 될 것 같습니다. 

실은 글의 _id는 근처의 result 변수안에 들어있는 것 같더라고요. 

 

 

 

app.post('/edit', async (요청, 응답)=>{
  await db.collection('post').updateOne({ _id : new ObjectId(요청.body.id) },
    {$set : { title : 요청.body.title, content : 요청.body.content }
  })
  응답.redirect('/list')
}) 

그래서 서버에선 요청.body.id 쓰면 출력해볼 수 있기 때문에

그걸로 첫 물음표를 잘 채워봤습니다. 

 

심심하시면 집에가서 안전하게 예외처리도 한번 해보도록 합시다. 

여러분들이 만든 API 기능을 악성유저처럼 한번 테스트해보면 되는데

- 유저가 글의 _id를 안보내면?

- 수정할 글을 보냈는데 글이 비어있으면?

- 글이 너무 길면? 

- DB에서 수정이 실패하고 에러가 나면?

 

등 여러가지 상황이 있겠군요. 

 

그리고 이런 것도 처리해주면 좋을거같은데 

지금 잘 보시면 유저가 <input name="id">내용을 막 만져버리면 어떻게 합니까 

그러면 안될거같죠? 이런건 숨겨놓는게 약간 더 안전할 거 같습니다. 

 

 

<input name="id"value="<%= result._id %>" style="display : none"> 

이런 스타일 주면 쉽게 숨길 수 있습니다. 

근데 이렇게 숨겨놔도 크롬 개발자도구 켜면 어짜피 다 보이고 맘대로 조작도 할 수 있습니다. 

그래서 프론트엔드에 있는건 모두 위조할 수 있기 때문에 

중요한 모든 데이터는 서버에서 검사해보는게 좋습니다. 