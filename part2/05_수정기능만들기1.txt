수정기능 만들기 1

 

1:00 1. 수정버튼 누르면 수정페이지로

5:06 2. 수정페이지엔 기존 글이 채워져있음 

9:54 3. 전송누르면 DB 글 수정

10:30 DB에 있던 document 수정하려면

 

 

글 수정기능을 만들어볼건데 

실은 수정기능 만드는건 상세페이지 했던거랑 약간 비슷한 것 같은데 

실력향상을 원하시면 강의끄고 직접 글 수정기능 만들어봅시다. 

혼자 코드를 짜봐야 혼자 코드짜는 실력이 늡니다.  

겁쟁이들은 저랑같이 해보고요 

 

 

 

 

 

수정기능이 뭐냐면

 

수정기능이 뭔지 한글로 설명부터 해봅시다.

다들 게시판서비스에서 글 수정같은거 해봤을거 아닙니까

 

1. 글마다 있는 수정버튼 누르면 글수정할 수 있는 페이지로 이동

2. 그 페이지엔 글의 제목과 내용이 이미 폼에 채워져있어야함

3. 전송누르면 그걸로 기존에 있던 document를 수정해줌 

여기서 모르는건 기존 document 수정하는 법 정도인 것 같은데 1번부터 해보도록 합시다. 

 

 

 

 

 

1. 글마다 있는 수정버튼 누르면 글 수정페이지 이동

 

버튼누르면 글 수정페이지로 이동시키고 싶으면 

<a href="/어쩌구">링크</a> 만들면 되겠죠? 

그리고 수정페이지의 URL도 하나 정하면 될거같습니다.

/edit 이걸로 합시다.

거기로 이동하면 edit.ejs 파일같은거 만들어서 보내주면 될 것 같습니다. 

 

<a href="/edit">✏️</a>

그래서 list.ejs 적절한 위치에 링크 하나 추가해봤습니다. 

글제목 옆이 좋지 않을까요 

 

근데 잘 생각해보시면 지금 글이 4개 있는데 수정페이지가 몇 개 필요하죠?

4개 필요합니다.

첫글 수정페이지 들어가면 첫글의 제목과 내용이 박혀있어야 하고

둘째글 수정페이지 들어가면 둘째글의 제목과 내용이 박혀있어야 합니다. 

 

 

app.get('/edit/1', (요청, 응답) => {
  응답.render('첫째글 수정페이지')
})

app.get('/edit/2', (요청, 응답) => {
  응답.render('둘째글 수정페이지')
})

... 계속

그래서 서버파일에다가 이렇게 4개의 수정페이지를 만들어두면 됩니다. 

근데 글이 1만개 있으면 어쩌죠?

1만번 복붙하면 되긴 하는데 

이런 뻘짓거리 싫으면 URL 파라미터 문법 사용하면 된다고 한 것 같습니다. 

 

 

app.get('/edit/:id', (요청, 응답) => {
  응답.render('edit.ejs')
})

이러면 됩니다. 

기념으로 수정페이지도 edit.ejs 이름으로 하나 만들어서 보내줍시다.  

edit.ejs 페이지 레이아웃은 그냥 write.ejs 그대로 복붙해서 쓰도록 합시다. 

(다른 게시판들 보면 수정누르면 글작성화면이랑 똑같은거 뜨지 않습니까)

 

그럼 이제 수정페이지 이동하는 링크도 만들 수 있을텐데 그건 나중에 해보도록 합시다. 

 

 

 

 

 

2. 수정페이지엔 글의 제목과 내용이 이미 채워져있어야함

 

수정페이지 들어가면 기존 글의 내용이 박혀있어야합니다.  

그럼 edit.ejs 보내줄 때 글 내용을 DB에서 꺼내서 ejs파일에 박아주면 되겠군요.

 

 

app.get('/edit/:id', async (요청, 응답) => {
  let result = await db.collection('post').findOne({ _id : new ObjectId(첫글_id) })
  응답.render('edit.ejs', {result : result})
})

document 하나 찾고 싶으면 .findOne 쓰면 됩니다. 

그래서 대충 이렇게 작성하면 첫 글이 채워진 수정페이지가 완성된 것 같은데

근데 이러면 안되겠죠? 

지금 어떻게 접속하든간에 매번 똑같은 첫 글의 제목과 내용만 보여줄 것 아닙니까. 

어쩔땐 둘째글, 어쩔땐 셋째글 내용을 보여주고 싶군요. 

 

 



 

저번에 이럴 때 어떻게 했는지 기억을 되살리면 

유저가 /edit/뒤에 글의 id를 입력해서 요청하면 

그 id를 가진 글의 제목과 내용을 DB에서 뽑아서 ejs파일로 보내주면 해결인듯요. 

그래서 잘 생각해보면 수정페이지도 상세페이지랑 뭔가 비슷합니다. 

 

 

 

app.get('/edit/:id', async (요청, 응답) => {
  let result = await db.collection('post').findOne({ _id : new ObjectId(유저가URL파라미터자리에입력한거) })
  응답.render('edit.ejs', {result : result})
})


그래서 코드 이렇게 바꾸면 됩니다.

유저가URL파라미터자리에입력한거가 코드로 뭐냐고요? 

까먹은건 검색해보면 됩니다. 

 

 

 

그래서 진짜있는 글의 _id를 넣어서 /edit/글_id 로 접속해보면 

edit.ejs 파일이 잘 나오는데 

 



 

▲ 근데 <input>에 글들이 채워져있진 않군요. 

<input>에 글을 미리 입력해두고 싶으면 value="미리입력할값" 속성을 추가하면 됩니다. 

 

(edit.ejs)

(생략)
<input name="title" value="<%= result.title %>">
<input name="title" value="<%= result.content %>">
그래서 result.title 같은걸 채워봤습니다.

변수는 언제나 어떤 값이 들어있을지 모르기 때문에 사용 전에 출력해보는게 좋은 습관입니다. 

 

 

 

3. 전송누르면 그걸로 기존에 있던 document를 수정해줌 

 

이제 3번기능 만들 것인데 

전송버튼 누르면 서버로 글을 전송할텐데 

그럼 서버는 그걸 검사하거나 하고 DB에 있던 내용을 그걸로 수정해주면 됩니다. 

DB에 있는 document 수정하는 법만 알려드릴테니까 집가서 3번기능 구현해오십시오. 

 

db.collection('post').updateOne( {수정할document정보}, {$set: {덮어쓸내용}}) 

DB에 있던 document 하나를 수정하고 싶으면 이거 쓰면 됩니다. 

 

 

db.collection('post').updateOne( { a : 1 }, {$set: { a : 2 }}) 

예를 들어 이렇게 작성하면 a : 1을 가진 document를 찾아서 a 항목을 2로 수정해줍니다. 

 

 

db.collection('post').updateOne( { _id : 2 }, {$set: { a : 3 }}) 

예를 들어 이렇게 작성하면 _id : 2를 가진 document를 찾아서 a 항목을 3으로 수정해줍니다.

 

 

 

 

오늘의 숙제 : 

다 알려드렸으니 수정기능을 알아서 완성해옵시다. 

(팁) 서버에서 어떤 데이터가 필요한데 서버에서 찾을 수 없다면 손가락 빨고 있지 말고 

유저에게 보내라고 하거나 / DB에서 출력해보거나 둘 중 하나 하면 됩니다.