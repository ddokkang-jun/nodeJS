삭제기능 만들기 2 (dataset)

 

0:00 첫 글의 삭제기능 만들기 

7:44 나머지 글들 삭제기능은?

8:58 다른 방법으로 글의 _id 가져올 수 있음 (dataset)

 

 

 

만들어오라던 삭제기능을 같이 만들어봅시다. 

오늘 새로배울 내용은 dataset 하나라서 삭제 잘되면 그거나 듣고 지나갑시다. 

 

 

 

 

첫 글의 삭제버튼 기능부터 만들어보자

 

한 번에 모든 버튼에 기능개발하려는 사람들이 많은데

그렇게 코딩하면 안됩니다.

초보들은 한 버튼의 기능만 먼저 만들어보고 그걸 확장해나가는 식으로 코드짜는게 더 쉽습니다.

그래서 첫 글의 삭제기능부터 완성해봅시다. 

첫째 글의 삭제기능 어떻게 만들어요? 

 

- 첫째 삭제버튼 누르면 서버로 삭제요청날리고

- 서버는 확인후에 DB에서 글 삭제해주면 

끝 아닙니까 

 

 

 

 

document.querySelectorAll('.delete')[0].addEventListener('click', function(){
  0번째 .delete 버튼 누르면 실행할 코드~~
}) 


첫째 버튼 누르면 서버로 삭제요청 날리고 싶으면 이거처럼 이벤트리스너 작성하면 된다고 했습니다. 

 

 

fetch('/delete', {
  method : 'DELETE',
}) 


그리고  이벤트리스너 안에 이런 코드 써서 DELETE 요청을 날려봤습니다.

 

이제 서버에서 API 만들면 될 것 같은데 

근데 잘 생각해보면 이렇게만 요청하면 서버는 무슨 document를 삭제해야할지 알까요?

서버가 점쟁이도 아니고 아마 모를겁니다.

그래서 아마 삭제하고싶은 document의 _id같은것도 보내라고 하지 않을까요 

아마 그럴 것 같습니다. 

 

 

 

 

fetch('/delete?docid=첫째글_id', {
  method : 'DELETE',
}) 


그래서 삭제할 글의 _id도 함께 서버로 보내보도록 합시다. 

body 이용해도 되는데 참고로 delete 요청할 때 body 보내면 잘 안가는 경우도 있어서 

쿼리스트링으로 보내봤습니다. 

 

그래서 첫째글의 _id 를 쿼리스트링으로 보내면 될텐데 첫째 글의 _id가 어딨어요? 

서버에서 보낸 <%= 글목록 %>이라는 변수 출력해보시면 있지않습니까 

출력해보면 아마 첫째글, 그러니까 0번째 글의 _id도 그 변수안에 들어있을걸요.

그걸 쿼리스트링에 넣어서 전송해야겠습니다. 

 

 

 

 

document.querySelectorAll('.delete')[0].addEventListener('click', function(){
  fetch('/delete?docid=' + '<%= 글목록[0]._id %>', {
    method : 'DELETE',
  })
}) 


첫 버튼의 삭제요청기능 완성

서버에서 /delete로 DELETE요청 잘 오는지 테스트해봅시다.

 

 

 

 

 

 

 

요청들어오면 서버는 삭제

 

삭제하라고 요청이 들어오면 

서버는 확인 후에 삭제해주면 됩니다. 

 

(server.js)

app.delete('/delete', async (요청, 응답) => {
  let result = await db.collection('post').deleteOne( { _id : new ObjectId(요청.query.docid) } )
  응답.send('삭제완료')
})


삭제하고 싶으면 .deleteOne() 써주면 됩니다. 

소괄호 안에는 삭제하고 싶은 document의 정보를 기입하면 되는데 { _id : 유저가보낸_id } 를 기입하면 되겠군요. 

진짜 삭제 잘 되는지 테스트해봅시다.

 

참고로 AJAX로 서버에 요청하는 경우 

서버는 요청.redirect() 요청.render() 이런걸 사용하면 안됩니다.

이런건 다른 페이지로 이동하는거라 새로고침되지않습니까. 

 

 

 

 

 

나머지 버튼도 개발해봅시다 

 

지금 0번째 버튼에만 기능개발해놨죠?

지금 0번째 버튼 클릭하면 DELETE 요청해주세요 라고 코드를 짜놨을 뿐입니다. 

1번째 버튼 누르면 서버로 또 삭제요청해주고싶으면 어떻게해요?

 

 

 

document.querySelectorAll('.delete')[1].addEventListener('click', function(){
  fetch('/delete?docid=' + '<%= 글목록[1]._id %>', {
    method : 'DELETE',
  })
}) 

[0]으로 기재된걸 [1]로 바꿔서 똑같이 한번 더 작성해주면 되겠죠?  

1번 버튼 누르면 서버로 지금 글의 _id를 적어서 DELETE요청 잘 보내줄 것 같군요. 

근데 이런 비슷한 코드 반복되면 뭐 쓰라고 했습니까

반복문 쓸 수 있을 것 같은데 한 번 써보시면 되겠습니다.

반복문 못 쓰겠으면 그냥 손수 글 갯수만큼 복붙하면 됩니다. 

 

 

 

 

 

 

 

_id 가져오는 다른 방법 dataset

 

자바스크립트 잘하면 이런 방법 써도 _id를 가져올 수 있는데

html에다가 _id 를 미리 중요한 정보를 숨겨놓고

클릭할 때 마다 가져올 수도 있습니다.

 

 

<span data-어쩌구="저쩌구"></span>

아무 html에다가 data-어쩌구="저쩌구" 이렇게 기입할 수 있는데 

이게 뭐냐면 어쩌구라는 이름으로 저쩌구라는 자료를 저장해두라는 뜻입니다. 

 

이 짓거리의 장점은 이 html요소를 클릭하거나 그런 경우

거기 숨겨놨던 데이터를 되게 쉽게 가져올 수가 있는데 

이벤트리스너 안에서 e.target.dataset.데이터이름 사용하면 숨겨놨던 데이터가 이 자리에 나옵니다. 

 

그래서 현재 게시물 _id같은것도 이 삭제버튼에다가 숨겨놓으면 

이 삭제버튼을 클릭했을 때 되게 쉽게 가져와서 쓸 수 있지않을까요.

 

 

 

(list.ejs)

<span class="delete" data-id="<%= 글목록[i]._id %>">🗑️</span>

예를 들어서 삭제버튼에 id라는 이름으로 글의 _id를 숨겨놓으면 

그럼 이제 요걸 클릭했을 때 e.target.dataset.id라고 쓰면 글의 _id를 가져다쓸 수 있으니까

 

 

document.querySelectorAll('.delete')[0].addEventListener('click', function(e){
  fetch('/delete?docid=' + e.target.dataset.id, {
    method : 'DELETE',
  })
}) 

이렇게 구현하셔도 상관없습니다.

(addEventListener 콜백함수 안에 e 파라미터 추가해야 사용가능)

 

개인적으로 아까보다는 이 방법이 더 나은거같은데

왜냐면 나중에 글들을 정렬하고 필터하고 그러면 html이 순서가 바뀌고 아니면 일부가 없어지고 그럴 수도 있을텐데

이걸 쓰면 글목록이 섞였을 때도 정확히 삭제요청을 날릴 수 있을 수 있겠군요. 

 

 

 

오늘의 교훈은 코드짤 때 맨날 한 번에 모든걸 구현하려고 하는 분들이 있는데 

그런건 코딩 고수나 하는 것이고

여러분들은 그러면 안되고 한 번에 하나의 기능부터 차근차근 구현하시면 됩니다. 